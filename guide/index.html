<!DOCTYPE html><html><head><title>Rivets.js â€” Lightweight and powerful data binding + templating solution for building modern web applications</title><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/type.css"><link rel="stylesheet" href="/css/screen.css"><link rel="stylesheet" href="/css/syntax.css"><link rel="stylesheet" href="/css/responsive.css"><script src="/js/jquery.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/highlight.js"></script><script src="/js/app.js"></script><meta name="viewport" content="width=device-width, initial-scale=1.0"><script type="text/javascript">hljs.initHighlightingOnLoad();

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-6079274-2']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></head><body data-spy="scroll" data-target="#nav"><header><div class="container"><div class="row"><div class="col col-xs-6"><h3 class="logotype"><a href="/">RIVETS</a></h3></div><div class="col col-xs-6 right visible-xs"><i id="hamburger">&#9776;</i></div><div id="menu" class="col col-sm-6 col-xs-12 right hidden-xs"><ul class="list-unstyled"><li><a href="/docs/guide">Guide</a></li><li><a href="/docs/reference">Binder Reference</a></li><li><a href="http://github.com/mikeric/rivets">GitHub</a></li></ul></div></div></div></header><section class="docs"><div class="container"><div class="row"><article class="guide col col-md-9"><h2 id="install">Installation</h2><p>You can grab the latest stable release <a href="/dist/rivets.min.js">here</a> or install using the package manager of your choice. We currently maintain releases on npm, component, jam and bower (recommended).</p>
<pre><code class="language-bash">bower install rivets</code></pre>
<p>Rivets&#39; only hard dependency is <a href="https://github.com/mikeric/sightglass">Sightglass</a>. If you wish to include Sightglass separately, just make sure to include it first.</p>
<pre><code class="language-html">&lt;script src=&quot;bower_components/sightglass/index.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;bower_components/rivets/dist/rivets.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>Alternatively you can just include the bundled distribution of Rivets, which contains both libraries.</p>
<pre><code class="language-html">&lt;script src=&quot;bower_components/rivets/dist/rivets.bundled.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p><em>Note that Rivets unconditionally occupies a <code>rivets</code> global but CommonJS and AMD module loaders such as <a href="http://requirejs.org/">RequireJS</a> and <a href="https://github.com/jrburke/almond">almond</a> are fully supported as well, if that&#39;s your thing.</em></p>
<h2 id="usage">Usage</h2><h3 id="usage-templates">Templates</h3><p>Templates describe your UI in plain HTML. You can define them directly in the document, use template elements or store and load them however you like. Just make sure you have a convenient way to reference your templates when you want to bind some data to them.</p>
<pre><code class="language-html">&lt;section id=&quot;auction&quot;&gt;
  &lt;h3&gt;{ auction.product.name }&lt;/h3&gt;
  &lt;p&gt;Current bid: { auction.currentBid | money }&lt;/p&gt;

  &lt;aside rv-if=&quot;auction.timeLeft | lt 120&quot;&gt;
    Hurry up! There is { auction.timeLeft | time } left.
  &lt;/aside&gt;
&lt;/section&gt;</code></pre>
<p>The important parts to note here are the attributes prefixed with <code>rv-</code> and portions of text wrapped in <code>{ ... }</code>. These are binding declarations and they are the sole way that Rivets.js ties data to your templates. The values of these declarations all follow the same minimal and expressive syntax.</p>
<pre><code>(keypath | primitive) [formatters...]</code></pre>
<p>Keypaths get observed and will recompute the binding when any intermediary key changes. A primitive can be a string, number, boolean, null or undefined.</p>
<p><a href="#formatters">Formatters</a> can be piped to values using <code>|</code> and they follow a similarly minimal yet expressive syntax. <a href="#formatters-arguments">Formatter arguments</a> can be keypaths or primitives. Keypath arguments get observed and will recompute the binding when any intermediary key changes.</p>
<pre><code>(formatter) [keypath | primitive...]</code></pre>
<h3 id="usage-binding">Binding</h3><p>Simply call <code>rivets.bind</code> on a template element with some data that you would like to bind.</p>
<pre><code class="language-javascript">rivets.bind($(&#39;#auction&#39;), {auction: auction})</code></pre>
<p><em>Every call to <code>rivets.bind</code> returns a fully data-bound view that you should hold on to for later. You&#39;ll need it in order to unbind it&#39;s listeners using <code>view.unbind()</code>.</em></p>
<h3 id="usage-configuring">Configuring</h3><p>Use <code>rivets.configure</code> to set the following configuration options for your app. Note that all configuration options can be overridden locally to a particular view if needed.</p>
<pre><code class="language-javascript">rivets.configure({

  // Attribute prefix in templates
  prefix: &#39;rv&#39;,

  // Preload templates with initial data on bind
  preloadData: true,

  // Root sightglass interface for keypaths
  rootInterface: &#39;.&#39;,

  // Template delimiters for text bindings
  templateDelimiters: [&#39;{&#39;, &#39;}&#39;],

  // Augment the event handler of the on-* binder
  handler: function(target, event, binding) {
    this.call(target, event, binding.view.models)
  }

})</code></pre>
<h2 id="binders">Binders</h2><p>Binders are the sets of instructions that tell Rivets.js how to update the DOM when an observed property changes. Rivets.js comes bundled with a handful commonly-used binders for your conveneience. See the <a href="/docs/reference/">Binder Reference</a> to learn more about the built-in binders that are available out of the box.</p>
<p>While you can accomplish most UI tasks with the built-in binders, it is highly encouraged to extend Rivets.js with your own binders that are specific to the needs of your application.</p>
<h3 id="binders-one-way">One-way binders</h3><p>One-way binders simply update the DOM when a model property changes (model-to-view only). Let&#39;s say we want a simple binder that updates an element&#39;s color when the model property changes. Here we can define a one-way <code>color</code> binder as a single function. This function takes the element and the current value of the model property, which we will use to updates the element&#39;s color.</p>
<pre><code class="language-javascript">rivets.binders.color = function(el, value) {
  el.style.color = value
}</code></pre>
<p>With the above binder defined, you can now utilize the <code>rv-color</code> declaration in your views.</p>
<pre><code class="language-html">&lt;button rv-color=&quot;label.color&quot;&gt;Apply&lt;/button&gt;</code></pre>
<h3 id="binders-two-way">Two-way binders</h3><p>Two-way binders, like one-way binders, can update the DOM when a model property changes (model-to-view) but can also update the model when the user interacts with the DOM (view-to-model), such as updating a control input, clicking an element or interacting with a third-party widget.</p>
<p>In order to update the model when the user interacts with the DOM, you need to tell Rivets.js how to bind and unbind to that DOM element to set the value on the model. Instead of defining the binder as a single function, two-way binders are defined as an object containing a few extra functions.</p>
<pre><code class="language-javascript">rivets.binders.toggle = {
  bind: function(el) {
    adapter = this.config.adapters[this.key.interface]
    model = this.model
    keypath = this.keypath

    this.callback = function() {
      value = adapter.read(model, keypath)
      adapter.publish(model, keypath, !value)
    }

    $(el).on(&#39;click&#39;, this.callback)
  },

  unbind: function(el) {
    $(el).off(&#39;click&#39;, this.callback)
  },

  routine: function(el, value) {
    $(el)[value ? &#39;addClass&#39; : &#39;removeClass&#39;](&#39;enabled&#39;)
  }
}</code></pre>
<h3 id="binders-api">API</h3><h4>binder.bind</h4>
<p>This function will get called for this binding on the initial <code>view.bind()</code>. Use it to store some initial state on the binding, or to set up any event listeners on the element.</p>
<h4>binder.unbind</h4>
<p>This function will get called for this binding on <code>view.unbind()</code>. Use it to reset any state on the element that would have been changed from the routine getting called, or to unbind any event listeners on the element that you&#39;ve set up in the <code>binder.bind</code> function.</p>
<h4>binder.routine</h4>
<p>The routine function is called when an observed attribute on the model changes and is used to update the DOM. When defining a one-way binder as a single function, it is actually the routine function that you&#39;re defining.</p>
<h4>binder.publishes</h4>
<p>Set this to true if you want view.publish() to call publish on these bindings.</p>
<h4>binder.block</h4>
<p>Blocks the current node and child nodes from being parsed (used for iteration binding as well as the if/unless binders).</p>
<h2 id="formatters">Formatters</h2><p>Formatters are functions that mutate the incoming and/or outgoing value of a binding. You can use them to format dates, numbers, currencies, etc. and because they work in a similar fashion to the Unix pipeline, the output of each feeds directly as input to the next one, so you can stack as many of them together as you like.</p>
<h3 id="formatters-one-way">One-way formatters</h3><p>This is by far the most common and practical way to use formatters &mdash; simple read-only mutations to a value. Taking the dates example from above, we can define a <code>date</code> formatter that returns a human-friendly version of a date value.</p>
<pre><code class="language-javascript">rivets.formatters.date = function(value){
  return moment(value).format(&#39;MMM DD, YYYY&#39;)
}</code></pre>
<p>Formatters are applied by piping them to binding declarations using <code>|</code> as a delimiter.</p>
<pre><code class="language-html">&lt;span rv-text=&quot;event.startDate | date&quot;&gt;&lt;/span&gt;</code></pre>
<h3 id="formatters-two-way">Two-way formatters</h3><p>Two-way formatters are useful when you want to store a value in a particular format, such as a unix epoch time or a cent value, but still let the user input the value in a different format.</p>
<p>Instead of defining the formatter as a single function, you define it as an object containing <code>read</code> and <code>publish</code> functions. When a formatter is defined as a single function, Rivets assumes it to be in the read direction only. When defined as an object, Rivets uses it&#39;s <code>read</code> and <code>publish</code> functions to effectively serialize and de-serialize the value.</p>
<p>Using the cent value example from above, let&#39;s say we want to store a monetary value as cents but let the user input it in a dollar amount and automatically round to two decimal places when setting the value on the model. For this we can define a two-way <code>currency</code> formatter.</p>
<pre><code class="language-javascript">rivets.formatters.currency = {
  read: function(value) {
    return (value / 100).toFixed(2)
  },
  publish: function(value) {
    return Math.round(parseFloat(value) * 100)
  }
}</code></pre>
<p>You can then bind using this formatter with any one-way or two-way binder.</p>
<pre><code class="language-html">&lt;input rv-value=&quot;item.price | currency&quot;&gt;</code></pre>
<p>Note that you can also chain bidirectional formatters with any other formatters, and in any order. They read from left to right, and publish from right to left, skipping any read-only formatters when publishing the value back to the model.</p>
<h3 id="formatters-arguments">Formatter arguments</h3><p>Formatters can accept any number of arguments in the form of keypaths or primitives. Keypath arguments get observed and will recompute the binding when any intermediary key changes. A primitive can be a string, number, boolean, null or undefined.</p>
<pre><code class="language-html">&lt;span&gt;{ alarm.time | time user.timezone &#39;hh:mm&#39; }&lt;/span&gt;</code></pre>
<p>The value of each argument in the binding declaration will be evaluated and passed into the formatter function as an additional argument.</p>
<pre><code class="language-javascript">rivets.formatters.time = function(value, timezone, format) {
  return moment(value).tz(timezone).format(format)
}</code></pre>
<h2 id="components">Components</h2><p>Components let you define reusable views that can be used within any of your templates. For some perspective on where components fit into your templates in relation to binders; binders define custom attributes, while components define custom elements.</p>
<p>A component object must define a <code>template</code> function, which returns the template for the component (this can be an HTML string or the actual element). It must also define an <code>initialize</code> function, which returns the scope object to bind the view with (this will likely be a controller / viewmodel / presenter).</p>
<pre><code class="language-javascript">rivets.components[&#39;todo-item&#39;] = {
  // Return the template for the component.
  template: function() {
    return JST[&#39;todos/todo-item&#39;]
  },

  // Takes the original element and the data that was passed into the
  // component (either from rivets.init or the attributes on the component
  // element in the template).
  initialize: function(el, data) {
    return new ItemController({
      item: data.item
    })
  }
}</code></pre>
<p>To use the component inside of a template, simply use an element with the same tag name as the component&#39;s key. All attributes on the element will get evaluated as keypaths before being passed into the component&#39;s <code>initialize</code> function.</p>
<pre><code class="language-html">&lt;todo-item item=&quot;myItem&quot;&gt;&lt;/todo-item&gt;</code></pre>
<p>These keypaths will also be observed in both directions so that the component will update if the value changes from the outside and it will set the value if the component changes it from the inside.</p>
<p>Additionally, if you want certain attributes to be static instead of an observed keypath, you can list them out on the <code>static</code> property fo your components.</p>
<pre><code class="language-javascript">rivets.components[&#39;todo-item&#39;] = {
  static: [&#39;list-style&#39;],
  â€¦
}</code></pre>
<pre><code class="language-html">&lt;todo-item item=&quot;myItem&quot; list-style=&quot;condensed&quot;&gt;&lt;/todo-item&gt;</code></pre>
<p>Components can also be initialized on their own, outside of a template. This is useful when you want to insert a new view into the DOM yourself, such as the entry point to your entire application or the content of a modal. The API is similar to <code>rivets.bind</code>, except that instead of passing it an actual template / element, you just pass it the name of the component and the root element you want the component to render in.</p>
<pre><code>rivets.init(&#39;my-app&#39;, $(&#39;body&#39;), {user: user})</code></pre>
<pre><code>rivets.init(&#39;todo-item&#39;, $(&#39;#modal-content&#39;), {item: myItem})</code></pre>
<h2 id="adapters">Adapters</h2><p>Rivets.js is agnostic about the objects that it can subscribe to. This makes it very flexible as it can adapt to work with virtually any library or framework, but it also means that you need to tell Rivets.js <em>how</em> to subscribe to those objects. This is where adapters come in to play. This feature is driven by the <a href="https://github.com/mikeric/sightglass">Sightglass</a> library.</p>
<p>Each adapter is defined to a unique interface (a single character) which is used to separate the keys in a keypath. The interfaces used in a keypath determine which adapter to use for each intermediary key.</p>
<pre><code>user.address:city</code></pre>
<p>The above keypath will use the <code>.</code> adapter to access the <code>address</code> key on the <code>user</code> object, and the <code>:</code> adapter to access the <code>city</code> key on the <code>address</code> object. If you can imagine for a second that <code>address</code> is just a normal property on the user object pointing to a Backbone model, but <code>city</code> is actually an attribute on that Backbone model, you can see how this kind of notation is actually very succint and expressive.</p>
<h3 id="adapters-default">The built-in adapter</h3><p>Rivets.js ships with a <code>.</code> adapter for subscribing to properties on plain JavaScript objects. The adapter is self-implemented using ES5 natives such as <code>Object.defineProperty</code>. In the future, this adapter will be implemented purely using <code>Object.observe</code> as soon as browser support permits.</p>
<p>If you need to support non-ES5 browsers (&lt; IE 9), you can replace this adapter to use polyfills or with a third-party library that has the browser support you need. If you&#39;re only targetting Chrome Canary, feel free to replace it with an <code>Object.observe</code> adapter now and enter data binding bliss.</p>
<h3 id="adapters-creating">Creating an adapter</h3><p>Adapters are defined on <code>rivets.adapters</code> with the interface as the property name and the adapter object as the value. An adapter is just an object that responds to <code>observe</code>, <code>unobserve</code>, <code>get</code> and <code>set</code>.</p>
<p>The following <code>:</code> adapter works for Backbone.js models / Stapes.js modules.</p>
<pre><code class="language-javascript">rivets.adapters[&#39;:&#39;] = {
  observe: function(obj, keypath, callback) {
    obj.on(&#39;change:&#39; + keypath, callback)
  },
  unobserve: function(obj, keypath, callback) {
    obj.off(&#39;change:&#39; + keypath, callback)
  },
  get: function(obj, keypath) {
    return obj.get(keypath)
  },
  set: function(obj, keypath, value) {
    obj.set(keypath, value)
  }
}</code></pre>
<h2 id="computed-properties">Computed Properties</h2><p>Computed properties are functions that get re-evaluated when one or more dependent properties change. Declaring computed properties in Rivets.js is simple, just separate the function from its dependencies with a <code>&lt;</code>. The following text binding will get re-evaluated with <code>event.duration()</code> when either the event&#39;s <code>start</code> or <code>end</code> attribute changes.</p>
<pre><code class="language-html">&lt;span rv-text=&quot;event.duration &lt; start end&quot;&gt;&lt;/span&gt;</code></pre>
<p>Note that the dependency keypaths stem from the target object, not the view&#39;s model context. So for the above declaration, the target is the <code>event</code> object, with dependencies on <code>event.start</code> and <code>event.end</code>.</p>
<h2 id="iteration">Iteration binding</h2><p>Use the <code>rv-each-[item]</code> binder to have Rivets.js automatically loop over items in an array and append bound instances of that element. Within that element you can bind to the iterated item as well as any contexts that are available in the parent view.</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li rv-each-todo=&quot;list.todos&quot;&gt;
    &lt;input type=&quot;checkbox&quot; rv-checked=&quot;todo.done&quot;&gt;
    &lt;span&gt;{ todo.summary }&lt;/span&gt;
  &lt;/li&gt;
&lt;ul&gt;</code></pre>
</article><aside class="col col-md-3 hidden-sm hidden-xs"><div class="pull-right"><nav id="nav" data-spy="affix" data-offset-top="145"><ul class="nav"><li><a href="#install"><strong>Installation</strong></a><ul class="nav"></ul></li><li><a href="#usage"><strong>Usage</strong></a><ul class="nav"><li><a href="#usage-templates">Templates</a></li><li><a href="#usage-binding">Binding</a></li><li><a href="#usage-configuring">Configuring</a></li></ul></li><li><a href="#binders"><strong>Binders</strong></a><ul class="nav"><li><a href="#binders-one-way">One-way binders</a></li><li><a href="#binders-two-way">Two-way binders</a></li><li><a href="#binders-api">API</a></li></ul></li><li><a href="#formatters"><strong>Formatters</strong></a><ul class="nav"><li><a href="#formatters-one-way">One-way formatters</a></li><li><a href="#formatters-two-way">Two-way formatters</a></li><li><a href="#formatters-arguments">Formatter arguments</a></li></ul></li><li><a href="#components"><strong>Components</strong></a><ul class="nav"></ul></li><li><a href="#adapters"><strong>Adapters</strong></a><ul class="nav"><li><a href="#adapters-default">The built-in adapter</a></li><li><a href="#adapters-creating">Creating an adapter</a></li></ul></li><li><a href="#computed-properties"><strong>Computed Properties</strong></a><ul class="nav"></ul></li><li><a href="#iteration"><strong>Iteration binding</strong></a><ul class="nav"></ul></li></ul></nav></div></aside></div></div></section></body></html>
